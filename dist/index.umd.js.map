{"version":3,"file":"index.umd.js","sources":["../node_modules/component-emitter/index.js","../src/socket-client.ts","../src/socket-server.ts"],"sourcesContent":["\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks['$' + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n\nimport Emitter from 'component-emitter';\nimport type { SocketServerMock } from '.';\n\n/**\n * Mocked Socket.IO client.\n */\nexport class SocketClientMock extends Emitter {\n  /**\n   * Are we currently connected?\n   * @default false\n   */\n  connected: boolean;\n\n  /**\n   * Are we currently disconnected?\n   * @default true\n   */\n  disconnected: boolean;\n\n  /**\n   * Mocked Socket.IO server.\n   */\n  serverMock: SocketServerMock;\n\n  _emitFn: (event: string, ...args: any[]) => Emitter;\n\n  /**\n   * Mocked Socket.IO client.\n   *\n   * @param {SocketServerMock} serverMock\n   */\n  constructor(serverMock: SocketServerMock) {\n    super();\n    this.serverMock = serverMock;\n    this._emitFn = Emitter.prototype.emit;\n\n    this.connected = false;\n    this.disconnected = true;\n  }\n\n  /**\n   * Emit an event to the server.\n   *\n   * If the last argument is a function, then it will be called\n   * as an 'ack' when the response is received. The parameter(s) of the\n   * ack will be whatever data is returned from the event\n   *\n   * @param {string}   event - The event that we're emitting\n   * @param {any[]}   args  - Optional arguments to send with the event\n   * @returns {Emitter<string>}\n   */\n  emit = (event: string, ...args: any[]): Emitter<string> => {\n    let ack;\n    if (typeof args[args.length - 1] === 'function') {\n      ack = args.pop();\n    }\n\n    return this.serverMock.emitEvent(event, args, ack);\n  };\n\n  /**\n   * Fire an event to the server.\n   *\n   * If the last argument is a function, then it will be called\n   * as an 'ack' when the response is received. The parameter(s) of the\n   * ack will be whatever data is returned from the event\n   *\n   * @param {string} event - The event that we're emitting\n   * @param {any[]} args - Optional arguments to send with the event\n   */\n  fireEvent = (event: string, ...args: any[]) => {\n    return this._emitFn(event, ...args);\n  };\n\n  /**\n   * Close the socket.\n   */\n  close = () => {\n    this.disconnected = true;\n    this.connected = false;\n    this.emit('disconnect', 'io client disconnect');\n    return this;\n  };\n\n  /**\n   * Disconnect the socket manually.\n   */\n  disconnect = () => {\n    return this.close();\n  };\n}\n\nexport default SocketClientMock;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n\nimport Emitter from 'component-emitter';\nimport { SocketClientMock } from './socket-client';\n\nconst createArgs = (args: any): any => {\n  return args ? JSON.parse(JSON.stringify(args)) : undefined;\n};\n\n/**\n * Mocked Socket.IO server.\n */\nexport class SocketServerMock extends Emitter {\n  /**\n   * Mocked Socket.IO client.\n   */\n  clientMock: SocketClientMock;\n\n  /**\n   * List of rooms.\n   */\n  rooms: string[];\n\n  _emitFn: (event: string, ...args: any[]) => Emitter;\n\n  generalCallbacks: {\n    [key: string]: Function;\n  };\n\n  /**\n   * Broadcast to a room.\n   *\n   * @return {Function} Broadcast options.\n   */\n  broadcast: {\n    /**\n     * Broadcast to a room.\n     *\n     * @param {string} room The room to broadcast to.\n     * @return {Function} Functions to perform on the room.\n     **/\n    to: (room: string) => {\n      /**\n       * Emit to the room.\n       *\n       * @param {string} event\n       * @param {any[]} args\n       **/\n      emit: (event: string, ...args: any[]) => void;\n    };\n  };\n\n  /**\n   * Creates a new SocketMock instance.\n   **/\n  constructor() {\n    super();\n\n    this.clientMock = new SocketClientMock(this);\n    this.rooms = [];\n\n    this._emitFn = Emitter.prototype.emit;\n    this.generalCallbacks = {};\n    this.broadcast = {\n      to: (room: string) => {\n        return {\n          emit: (event: string, ...args: any[]) => {\n            if (this.generalCallbacks[event]) {\n              this.generalCallbacks[event](...args.map(createArgs), room);\n            }\n          },\n        };\n      },\n    };\n\n    this.clientMock.connected = true;\n    this.clientMock.disconnected = false;\n    this.emit('connect');\n  }\n\n  /**\n   * Emit an event to the server (used by client).\n   *\n   * @param {string} event - The event.\n   * @param {any[]} args - Additional args.\n   * @param {Emitter} ack - The ack argument is optional. When the server calls it, args reply will be delivered to client\n   **/\n  emitEvent = (event: string, args: any[], ack?: Function): Emitter => {\n    return this._emitFn(event, ...args.map(createArgs), ack);\n  };\n\n  /**\n   * Register on every event that the server sends.\n   * @param {string} event\n   * @param {Function} callback\n   **/\n  onEmit = (event: string, callback: Function) => {\n    this.generalCallbacks[event] = callback;\n  };\n\n  /**\n   * Emit an event to the client.\n   *\n   * @param {string} event - The event.\n   * @param {any[]} args - Additional args.\n   **/\n  emit = (event: string, ...args: any[]) => {\n    return this.clientMock.fireEvent(event, ...args);\n  };\n\n  /**\n   * Join a room.\n   *\n   * @param {string} room The room we want to join.\n   **/\n  join = (room: string) => {\n    this.rooms.push(room);\n  };\n\n  /**\n   * Leave a room.\n   *\n   * @param {string} room The room you want to leave.\n   **/\n  leave = (room: string) => {\n    const index = this.rooms.indexOf(room);\n    this.rooms.splice(index, 1);\n  };\n\n  /**\n   * Monitor logging feature.\n   *\n   * @param {string} value The value you want to monitor.\n   **/\n  monitor = (value: string): string => {\n    return value;\n  };\n\n  /**\n   * Close the socket server.\n   *\n   * @returns {SocketServerMock} The mocked Socket.IO server.\n   */\n  disconnect = (): SocketServerMock => {\n    this.emit('disconnecting', 'Socket.IO mock server disconnect');\n    this.emit('disconnect', 'Socket.IO mock server disconnect');\n    this._emitFn('disconnecting', 'Socket.IO mock server disconnect');\n    this._emitFn('disconnect', 'Socket.IO mock server disconnect');\n    return this;\n  };\n\n  /**\n   * Broadcast to a room.\n   *\n   * @param {string} room The room to broadcast to.\n   * @return {Record<string, Function>} Functions to perform on the room.\n   **/\n  to = (room: string): Record<string, Function> => {\n    return {\n      /**\n       * Emit an event to the room.\n       *\n       * @param {string} event\n       * @param {any[]} args\n       **/\n      emit: (event: string, ...args: any[]) => {\n        if (this.generalCallbacks[event]) {\n          this.generalCallbacks[event](...args.map(createArgs), room);\n        }\n      },\n    };\n  };\n}\n\nexport default SocketServerMock;\n"],"names":[],"mappings":"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"}